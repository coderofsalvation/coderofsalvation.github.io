<h1>How to create transferable, mobile webprojects</h1>
<p><br> <img align="right" src="/data/upload/images/comic/out/comic_userfoo.jpg"/></p>
<h3>Quote </h3>
<blockquote>
<p><em>Any code of your own that you havent looked at for six or more months might as well have been written by someone else.</em></p>
<p>&#8212; quote by Eaglesons law </p>
</blockquote>
<h3>What is a transferable webproject </h3>
<p>A transferable project which can easily picked up by a collegue developer, and radiates similarity in workflow compared to other projects.</p>
<h3>How to get similarity in projects </h3>
<p>From important to less important:</p>
<ul>
<li>
see other programmers as yourself (empathy)
</li><li>
using the same issue/bugtracker to manage bugs/todos
</li><li>
using the same subversioning workflows (git/svn)
</li><li>
use the same codingconvention / code documentation snippets
</li><li>
always redirect emails to the issue/bugtracker
</li><li>
document howtos/workflows in the sourcetree or issue/bugtracker
</li><li>
try to work live on webservers, using vim/emacs or something else respectable
</li><li>
try to automate repeated processes, write build-, test-, import- and export-scripts
</li><li>
provide at least some sequencediagrams to show the vital workflows
</li><li>
focus on small function bodies
</li><li>
generate further documentation on your code (when a long livecycle is necessary).
</li>
</ul>
<p><code>Disclaimer: the above guidelines are matching my taste, other configurations are also possible.</code> </p>
<p>One might wonder why documentation is less important then the other aspects. Well, it can be of great help, but documenting stuff is also like flossing: everybody agrees, not many do it.  Also, sometimes debuggingskills might come more in handy in case of urgent bugfixing.</p>
<h3>Obstacles </h3>
<p>These things might interfere between collegues/projects:</p>
<ul>
<li>
several servers / passwords (for deployment etc)
</li><li>
filesystem permissions
</li><li>
incompatible massive-gui-editor projectfiles
</li><li>
programming too long alone on your project 
</li><li>
non-portable project-legacy, the project started from scratch and transformed into something mysterious.
</li><li>
exotic desktoptools which are necessary for building the application
</li>
</ul>
<h3>Solution: introduce a virtual college called 'foo' </h3>
<p>Who is person foo? Person foo is the virtual 'collegue'. Many problems can be solved just by introducing an nonexisting collegue, who has its own:</p>
<ul>
<li>
own unix account (filesystem/permission/crons)
</li><li>
own email (issuetracker user)
</li><li>
own IRC/Facebook/etc-messenger-bot (for namedpipe-to-chat logging)
</li><li>
own dropbox
</li><li>
own google account (to sync issues to excel-spreadsheets online)
</li>
</ul>
<p>Many problems can be solved by running tasks under this username.</p>
<p>Example: <em>Person A installs a cron which generates reports, and or receives a lot of stats/important info exclusively in his mailbox. Person A quits the company. Nobody has any clue where to look for. This is unwanted extra work.</em></p>
<p>Ok one can argue why somebody would do these activities, but the reality is that programmers are humans. Humans make misstakes, and usually each human 'knows/does something special' on the server(s). Many problems can be solved by sharing the 'foo' emailbox, or running cronscripts under users-privileges foo. Foo will never leave the company.</p>
<h3>Cream on the Cake </h3>
<p>Run all team-related cronjobs by user 'foo' run. A fully automated customized devserver can be hard to debug if everybody is running their own team-related crons. Advicable is to write a monitorscript, run by user 'foo' crontab, which checks if all necessary processes actually run. Imagine, collegue 'foo' is awake for 24 hours..and can always watch/assert things. Isnt there something really powerfull in this?</p>
<h3>But what about PaaS? </h3>
<p>In times of SaaS and PaaS it is not always possible to get away from IaaS. Sometimes SaaS-projects are so specific, and need specific serverconfigurations. In those cases it can pay off to introduce user 'foo' to those IaaS systems.</p>
<p><em>User foo is always at your service, even when your collegues leave</em></p>

